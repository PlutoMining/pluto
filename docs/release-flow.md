## Pluto Release and Umbrel Community Store Flow

This document describes how to publish Pluto releases in two stages:

1. **Publish Docker images** (source of truth: `PlutoMining/pluto`)
2. **Publish Umbrel apps via the community store** (source of truth: `PlutoMining/umbrel-community-app-store`)

There is also an optional **direct-to-device** flow for internal testing on a local Umbrel box.

---

### 1. Publish Docker images (Pluto repo)

All image publishing happens from the main Pluto repository.

#### 1.1 Stable releases

To build and push stable images:

```bash
scripts/release.sh
```

What it does:

- For each service: `backend`, `discovery`, `frontend`, `grafana`, `prometheus`:
  - Prompts for the version to use (or keeps the current one if `--bump-version` is not used).
  - Builds multi-arch images with `docker buildx`.
  - Pushes to:

  ```text
    ghcr.io/plutomining/pluto-<service>:<version>
    ghcr.io/plutomining/pluto-<service>:latest
  ```
  - **Automatically updates** `docker-compose.release.local.yml` with the new image references (for local testing of stable releases).

**Automation options:**

- `--skip-login` - Skip Docker login prompt (useful for CI/CD)
- `--bump-version` - Automatically bump `package.json` versions (patch increment, e.g., `1.1.2` → `1.1.3`)
- `--update-manifests` - Automatically update `pluto` umbrel-app manifests after building images
- `--sync-to-umbrel` - Automatically sync manifests to your Umbrel device (requires `--update-manifests`)
- `--skip-changelog` - Skip automatic changelog generation (changelog is generated by default)
- `--verbose` - Enable verbose logging with timestamps
- `--quiet` - Minimal output (errors only)
- `--dry-run` - Print actions without building/pushing or editing files

**By default**, the script does not touch Umbrel manifests or compose files. Use the flags above to enable automated manifest updates and device syncing.

This script only handles stable releases for the `pluto` app. For beta releases, use `scripts/beta-release.sh` (see below).

#### 1.2 Beta releases

To build and push beta images:

```bash
scripts/beta-release.sh
# or explicitly:
scripts/beta-release.sh --services "frontend,backend" --app-version 1.5.0-beta.1
```

What it does:

- Detects which services changed since `origin/main` (or uses `--services`).
- Reads the prerelease versions from each service's `package.json` (e.g. `1.5.0-beta.1`).
- Builds and pushes multi-arch images for the selected services to:

  ```text
  ghcr.io/plutomining/pluto-<service>:<pre-release-version>
  ```
  - **Automatically updates** `docker-compose.next.local.yml` with the new image references (for local testing of beta releases).

**Automation options:**

- `--skip-login` - Skip Docker login prompt (useful for CI/CD)
- `--bump-version` - Automatically bumps `package.json` versions to beta before building:
  - If current version is stable (e.g., `1.1.2`) → bumps to `1.1.3-beta.0`
  - If current version is already beta (e.g., `1.1.3-beta.1`) → increments to `1.1.3-beta.2`
- `--update-manifests` - Automatically updates `pluto-next` umbrel-app manifests after building images
- `--sync-to-umbrel` - Automatically syncs manifests to your Umbrel device (requires `--update-manifests`)
- `--skip-ci-check` - Skip CI status check (not recommended, only use if CI is unavailable)
- `--verbose` - Enable verbose logging with timestamps
- `--quiet` - Minimal output (errors only)
- `--dry-run` - Print actions without building/pushing or editing files

**Beta-specific options:**

- `--services "svc1,svc2"` - Comma-separated list of services to release (override auto-detection)
- `--app-version X.Y.Z-pr` - Explicit pluto-next app version to write into umbrel-app.yml
- `--diff-base <ref>` - Git ref (default: `origin/main`) used to detect changed services
- `--tag-suffix <suffix>` - Secondary tag pushed alongside the explicit version (default: `beta`)

**Pre-release checks (enforced):**

Before building images, the script performs several safety checks:

1. **Branch validation**: Ensures you're not on the `main` branch (beta releases must come from feature branches)
2. **Branch alignment with main**: Verifies your branch is up-to-date with `origin/main` (prevents releasing from outdated branches)
3. **Local/remote sync**: Ensures all local commits are pushed to the remote branch (prevents releasing unpublished code)
4. **Uncommitted files warning**: Warns if there are uncommitted changes and prompts for confirmation
5. **CI status check**: Verifies that all CI tests are passing before allowing the release:
   - Blocks if CI is still running
   - Blocks if CI failed
   - Blocks if CI was cancelled
   - Allows only if CI passed successfully
   - Requires `GITHUB_TOKEN` environment variable (or prompts for it)
   - Can be skipped with `--skip-ci-check` (not recommended)

These checks ensure that beta releases only happen from branches that are:
- Up-to-date with `main`
- Fully pushed to remote
- Passing all CI tests
- Clean working directory (or explicitly confirmed)

**By default**, the script does not touch Umbrel manifests or compose files. Use the flags above to enable automated manifest updates and device syncing.

> At this point, all Docker images required for a release (stable or beta) are available in `ghcr.io/plutomining`. The next step is to publish them to Umbrel users via the community app store.

---

### 2. Publish to Umbrel via the community app store

The Umbrel app manifests for public users live in the community store repository:

- [`PlutoMining/umbrel-community-app-store`](https://github.com/PlutoMining/umbrel-community-app-store)

Structure:

- `pluto-mining-pluto/` → stable app
- `pluto-mining-pluto-next/` → beta app

Each app contains its own:

- `umbrel-app.yml`
- `docker-compose.yml`
- `data/` and `images/` directories

#### 2.1 Store-side update script

In the community store repo there is a script:

```bash
scripts/update-pluto-from-registry.sh
```

Usage:

```bash
scripts/update-pluto-from-registry.sh \
  --channel stable|beta \
  --app-version X.Y.Z[-beta.N]
```

Behavior:

- Resolves the service images for the requested `app-version`:

  ```text
  ghcr.io/plutomining/pluto-backend:<app_version>
  ghcr.io/plutomining/pluto-frontend:<app_version>
  ...
  ```

- Uses `docker buildx imagetools inspect` and `jq` to get immutable digests for each image.
- Computes a **bundle fingerprint** from the current images in:
  - `pluto-mining-pluto/docker-compose.yml` (for `stable`), or
  - `pluto-mining-pluto-next/docker-compose.yml` (for `beta`).
- Computes a new fingerprint based on the desired images.
- If the bundle changed:
  - **Bumps the app version** in the corresponding `umbrel-app.yml`, using the same logic as in the Pluto repo:
    - **Stable** (`X.Y.Z`):
      - If the new base `X'.Y'.Z'` > current → `X'.Y'.Z'`.
      - Otherwise → increment patch `X.Y.(Z+1)`.
    - **Beta** (`X.Y.Z-beta.N`):
      - If base changed → `X'.Y'.Z'-beta.0`.
      - Otherwise → `X.Y.Z-beta.(N+1)`.
  - Updates `docker-compose.yml` `image:` refs to the new `image:tag@sha256:digest`.

This script is not run manually very often; it is typically invoked via a GitHub Action.

#### 2.2 GitHub Action: “Update Pluto app from registry”

The community store repo has an Actions workflow: `.github/workflows/update-pluto.yml`.

- Trigger: `workflow_dispatch` with inputs:
  - `channel`: `stable` or `beta`
  - `app_version`: e.g. `1.4.0` or `1.5.0-beta.1`

Flow:

1. Checkout the repo.
2. Setup Docker Buildx.
3. Install `jq`.
4. Login to GHCR using the repository secret `GHCR_TOKEN`.
5. Run:

   ```bash
   scripts/update-pluto-from-registry.sh \
     --channel "${{ github.event.inputs.channel }}" \
     --app-version "${{ github.event.inputs.app_version }}"
   ```

6. If any changes were made to manifests:
   - Commit the updated `umbrel-app.yml` and `docker-compose.yml`.
   - Push to the repository.

**Maintainer flow to publish a new release to Umbrel users:**

1. From the Pluto repo: publish images via `scripts/release.sh` (stable) or `scripts/beta-release.sh` (beta).
2. From the community store repo (on GitHub):
   - Go to **Actions → “Update Pluto app from registry”**.
   - Run the workflow with:
     - `channel = stable` and `app_version = X.Y.Z` for the stable app, or
     - `channel = beta` and `app_version = X.Y.Z-beta.N` for the beta app.
3. Once the workflow completes and pushes, Umbrel users see the updated versions and can install/upgrade:
   - Stable: `pluto-mining-pluto`
   - Beta: `pluto-mining-pluto-next`

---

### 3. Optional: local Umbrel device testing from the Pluto repo

For internal/dev testing on a specific Umbrel box you can deploy directly from the Pluto repo. This flow automatically updates local Umbrel app manifests and optionally syncs them to your device.

#### 3.1 Automated local publish

After building/publishing images as in section 1, use the `local-publish.sh` script to update manifests and optionally sync to your Umbrel device:

**For stable (pluto):**

**Option 1: Fully automated (recommended)**

```bash
# Build/push images, bump versions, update manifests, and sync to device in one command
scripts/release.sh --bump-version --update-manifests --sync-to-umbrel

# For CI/CD (skip interactive login):
scripts/release.sh --skip-login --bump-version --update-manifests --sync-to-umbrel
```

This single command will:
- Automatically bump `package.json` versions (patch increment, e.g., `1.1.2` → `1.1.3`)
- Build and push Docker images
- Update `pluto` manifests with new image references
- Sync manifests to your Umbrel device and reinstall the app

**Option 2: Two-step process**

```bash
# Build/push images first (with optional version bumping)
scripts/release.sh --bump-version

# Update local manifests and sync to Umbrel device
scripts/local-publish.sh --channel stable --sync-to-umbrel
```

Use Option 2 if you want more control over the process or prefer interactive version prompts.

**For beta (pluto-next):**

**Option 1: Fully automated (recommended for testing)**

```bash
# Build/push images, bump versions, update manifests, and sync to device in one command
# Note: Requires GITHUB_TOKEN env var for CI checks, or will prompt for it
GITHUB_TOKEN=your_token scripts/beta-release.sh --services backend --bump-version --update-manifests --sync-to-umbrel

# For CI/CD (skip interactive login, CI check still runs):
GITHUB_TOKEN=your_token scripts/beta-release.sh --skip-login --services backend --bump-version --update-manifests --sync-to-umbrel

# Auto-detect changed services:
GITHUB_TOKEN=your_token scripts/beta-release.sh --bump-version --update-manifests --sync-to-umbrel
```

This single command will:
- **Run pre-release checks**: Verify branch alignment, all commits pushed, and CI passing
- Automatically bump `package.json` versions to beta (e.g., `1.1.2` → `1.1.3-beta.0`)
- Build and push Docker images
- Update `pluto-next` manifests with new image references
- Sync manifests to your Umbrel device and reinstall the app

**Option 2: Two-step process**

```bash
# Build/push images first (with optional version bumping)
scripts/beta-release.sh --services backend --bump-version

# Update local manifests and sync to Umbrel device
scripts/local-publish.sh --channel beta --sync-to-umbrel
```

Use Option 2 if you want more control over the process or if you're updating multiple services.

What `local-publish.sh` does automatically:

- **Infers all parameters** from the `--channel` flag:
  - App name (`pluto` for stable, `pluto-next` for beta)
  - Manifest and compose file paths (`umbrel-apps/<app>/umbrel-app.yml` and `docker-compose.yml`)
- **Reads service versions** from each service's `package.json`:
  - `backend`, `discovery`, `frontend`, `grafana`, `prometheus`
- **Resolves image digests** automatically:
  - Builds image tags: `ghcr.io/plutomining/pluto-<service>:<version>`
  - Uses `docker buildx imagetools inspect` to get SHA256 digests
- **Updates manifests** using the same version-bump logic as the community store:
  - Calls `scripts/bump-umbrel-app-version.sh` internally with all inferred parameters
  - Bumps app version in `umbrel-app.yml` if the image bundle changed
  - Updates `docker-compose.yml` with new image refs pinned to digests
- **Optionally syncs to device** (if `--sync-to-umbrel` is passed):
  - Runs `scripts/sync-umbrel-apps.sh` to rsync manifests and reinstall apps on your Umbrel device

**Without `--sync-to-umbrel`**, the script only updates local manifests. You can then manually run `scripts/sync-umbrel-apps.sh` later if needed.

This gives you a fast, automated inner loop for testing new builds before pushing anything to the community store.

#### 3.2 Local testing with production-like images

After running the release scripts, you can test the exact production images locally using the updated compose files:

**For stable releases:**
```bash
# Start stable release services locally
make up-stable

# View logs
make logs-stable

# Stop services
make down-stable
```

**For beta releases:**
```bash
# Start beta release services locally
make up-beta

# View logs
make logs-beta

# Stop services
make down-beta
```

These commands use `docker-compose.release.local.yml` (stable) and `docker-compose.next.local.yml` (beta), which are automatically updated by the release scripts with the latest image references. This allows you to test the exact same images that will be deployed to Umbrel, but run locally for faster iteration.

---

### 4. Summary

- **Pluto repo (`PlutoMining/pluto`)**:
  - `scripts/lib/common.sh` → shared library containing common functions used across multiple scripts (logging, Docker image operations, GitHub API, `.env` file loading, etc.). All release scripts source this library.
  - `scripts/release.sh` → build and push stable images for `pluto` app. Common options: `--skip-login`, `--bump-version`, `--update-manifests`, `--sync-to-umbrel`, `--dry-run`.
  - `scripts/beta-release.sh` → build and push beta images for `pluto-next` app. Common options: `--skip-login`, `--bump-version`, `--update-manifests`, `--sync-to-umbrel`, `--skip-ci-check`, `--dry-run`. Beta-specific: `--services`, `--app-version`, `--diff-base`, `--tag-suffix`. **Enforces pre-release checks**: branch alignment, all commits pushed, CI passing. Requires `GITHUB_TOKEN` env var for CI checks.
  - `scripts/local-publish.sh` → automated wrapper to update local Umbrel manifests and optionally sync to device (infers all parameters from channel).
  - `scripts/bump-umbrel-app-version.sh` → low-level helper used internally by `local-publish.sh`, `release.sh`, and `beta-release.sh` (can be called directly if needed).
  - `scripts/sync-umbrel-apps.sh` → syncs Umbrel app manifests to a local Umbrel device and reinstalls apps.

- **Community store repo (`PlutoMining/umbrel-community-app-store`)**:
  - `scripts/update-pluto-from-registry.sh` → pulls latest images for a given app version and updates the store’s `umbrel-app.yml` and `docker-compose.yml`.
  - `.github/workflows/update-pluto.yml` → wraps the script with a manual “Update from registry” Action for maintainers.

This separation lets you iterate on images independently, then deliberately "publish" a given image set to Umbrel users via the community app store.

---

## 5. Changelog Generation

The release scripts automatically generate changelogs from conventional commits using [semantic-release](https://semantic-release.gitbook.io/). This happens automatically after successful releases.

### 5.1 How it works

**For stable releases (on `main` branch):**

After a successful release, the scripts automatically:

1. Analyze commits since the last release tag (or all commits if no tags exist yet)
2. Generate `CHANGELOG.md` based on conventional commit messages
3. Create a git tag (e.g., `v1.0.0`) to mark the release
4. Commit the changelog update (if changes were made)
5. Optionally create a GitHub release with the changelog

**How semantic-release prevents duplicates:**

- Semantic-release uses **git tags** to track what's been released
- The first time it runs (if no tags exist), it analyzes all commits from the start
- After the first release, it creates a tag (e.g., `v1.0.0`)
- The next time it runs, it **only analyzes commits after the last tag**
- This ensures no duplicate changelog entries

**Example workflow:**
1. First release: Analyzes all commits → Creates tag `v1.0.0` → Generates changelog
2. Second release: Analyzes commits after `v1.0.0` → Creates tag `v1.1.0` → Appends to changelog
3. Third release: Analyzes commits after `v1.1.0` → Creates tag `v1.2.0` → Appends to changelog

**Important for squash-and-merge workflow:**

Since you use squash-and-merge for PRs, semantic-release analyzes the **squashed commit message** on `main`. To ensure proper changelog generation:

- **PR titles must follow conventional commits format** (e.g., `feat(backend): add new feature`)
- The squashed commit message will be the PR title
- Semantic-release runs on `main` after the merge
- Individual commits in the PR don't need to follow conventional commits (only the PR title matters)

**Example PR title:**
```
feat(backend): add user authentication endpoint
```

This will be analyzed by semantic-release as a `feat` type commit, triggering a minor version bump in the changelog.

**For beta releases (on feature branches):**

**Changelog generation is skipped for beta releases.** This prevents duplicate entries when the branch is later merged to `main` and a stable release is made. The changelog is only generated on stable releases (on `main` branch) after PR merge.

### 5.2 Standalone changelog generation

You can also generate the changelog independently:

```bash
# Preview what would be generated (dry-run)
# Note: Works on any branch for testing purposes
scripts/generate-changelog.sh --dry-run

# Generate changelog without committing (must be on main branch)
scripts/generate-changelog.sh --skip-commit

# Generate and commit changelog (must be on main branch)
scripts/generate-changelog.sh
```

**Testing changelog generation:**

To test how semantic-release would analyze your commits, use `--dry-run` mode. This works on any branch:

```bash
# Test on your feature branch
scripts/generate-changelog.sh --dry-run
```

The dry-run mode will:
- Show what version would be released
- Show what changelog entries would be generated
- Show what commits would be analyzed
- **Not make any changes** to files or git

For actual changelog generation, you must be on the `main` branch.

### 5.3 Conventional Commits

To ensure proper changelog generation, all commits must follow the [Conventional Commits](https://www.conventionalcommits.org/) specification.

#### Commit message format

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

#### Commit types

- `feat`: A new feature (triggers minor version bump in changelog)
- `fix`: A bug fix (triggers patch version bump in changelog)
- `docs`: Documentation only changes
- `style`: Code style changes (formatting, missing semi colons, etc.)
- `refactor`: Code refactoring
- `perf`: Performance improvements
- `test`: Adding or updating tests
- `build`: Changes to build system or dependencies
- `ci`: Changes to CI configuration
- `chore`: Other changes that don't modify src or test files
- `revert`: Reverts a previous commit

#### Scopes

Scopes are optional but recommended. Valid scopes for this project:

- `backend`, `frontend`, `discovery`, `grafana`, `prometheus`, `mock` - Service-specific changes
- `common` - Changes to shared/common code
- `scripts` - Changes to release/utility scripts
- `docs` - Documentation changes
- `release` - Release-related changes

#### Examples

```bash
# Feature with scope
git commit -m "feat(backend): add user authentication endpoint"

# Bug fix
git commit -m "fix(frontend): resolve login form validation bug"

# Breaking change (use ! after type)
git commit -m "feat(backend)!: change API response format"

# Or use BREAKING CHANGE footer
git commit -m "feat(backend): update API

BREAKING CHANGE: API response format has changed from JSON to YAML"

# Documentation
git commit -m "docs: update release flow documentation"

# Multiple services
git commit -m "feat(backend,frontend): add real-time notifications"
```

### 5.4 Commit message validation

Commit messages are automatically validated using [commitlint](https://commitlint.js.org/) with Git hooks (via [husky](https://typicode.github.io/husky/)).

**To bypass validation** (not recommended):
```bash
git commit --no-verify -m "your message"
```

**To set up Git hooks** (run once after cloning):
```bash
npm install
npm run prepare  # Sets up husky hooks
```

### 5.5 Changelog format

The generated changelog follows this format:

```markdown
## [1.2.0] - 2024-01-15

### Features
* **backend**: add user authentication endpoint
* **frontend**: add real-time notifications

### Bug Fixes
* **frontend**: resolve login form validation bug

### Documentation
* update release flow documentation
```

---

## 6. Enhanced Features

### 6.1 Improved error handling

The release scripts now include:

- **Automatic retries**: Network operations (Docker builds, image pushes) are automatically retried with exponential backoff
- **Better error messages**: Clear, actionable error messages with context
- **Error recovery**: Scripts track progress and provide recovery suggestions on failure
- **Stack traces**: Enable with `--verbose` flag for debugging

### 6.2 Enhanced validation

Pre-flight checks before starting a release:

- **Docker daemon**: Verifies Docker is running
- **Disk space**: Checks available disk space (warns if < 5GB)
- **Git state**: Validates git repository state
- **Version format**: Ensures all versions follow semantic versioning
- **Image existence**: Checks if images already exist in registry (skips rebuild if found)
- **Service versions**: Validates version consistency across services

### 6.3 Improved logging

- **Colored output**: Color-coded messages (green for success, yellow for warnings, red for errors)
- **Progress indicators**: Visual progress for long-running operations
- **Structured output**: Clear sections and summaries
- **Verbose mode**: `--verbose` flag for detailed logging with timestamps
- **Quiet mode**: `--quiet` flag for minimal output (errors only)

### 6.4 Summary output

After successful releases, the scripts print a summary:

```
════════════════════════════════════════
Summary
════════════════════════════════════════
[success] backend: v1.1.3
[success] frontend: v1.1.3
[success] discovery: v1.1.3
════════════════════════════════════════
```

---

## 7. Troubleshooting

### 7.1 Changelog generation fails

**Problem**: Changelog generation fails or is skipped.

**Solutions**:
- **For stable releases**: Ensure you're on `main` branch. Changelog only generates on `main` after PR merge.
- **For squash-and-merge**: Ensure PR titles follow conventional commits format (e.g., `feat(backend): add feature`). The PR title becomes the commit message.
- Ensure `semantic-release` is installed: `npm install`
- Check that commits follow conventional commit format
- Verify `GITHUB_TOKEN` is set (optional, only needed for GitHub releases)
- Use `--skip-changelog` to skip if not needed (only for stable releases)
- **For beta releases**: Changelog generation is intentionally skipped to avoid duplicates when merging to main

### 7.1.1 Changelog analyzes all commits

**Problem**: Semantic-release is analyzing all commits from the start of the project.

**Explanation**: This is **normal behavior** for the first run. Semantic-release uses git tags to track releases:
- **First run** (no tags): Analyzes all commits from the start
- **After first release**: Creates a tag (e.g., `v1.0.0`)
- **Subsequent runs**: Only analyzes commits after the last tag

**Solutions**:
- This is expected - the first release will create a tag
- After the first release, subsequent runs will only analyze new commits
- If you want to start from a specific version, create an initial tag: `git tag v1.0.0`
- Semantic-release will then only analyze commits after that tag

### 7.2 Commit message validation fails

**Problem**: Git commit is rejected due to invalid commit message format.

**Solutions**:
- Review the commit message format (see section 5.3)
- Use `git commit --no-verify` to bypass (not recommended)
- Fix the commit message: `git commit --amend`

### 7.3 Docker build fails

**Problem**: Docker build fails with network or resource errors.

**Solutions**:
- Check Docker daemon is running: `docker info`
- Verify disk space: `df -h`
- Check network connectivity
- Scripts automatically retry failed builds (up to 2 attempts)

### 7.4 Image already exists

**Problem**: Script skips building because image already exists in registry.

**Solutions**:
- This is expected behavior - script skips rebuild if version unchanged and image exists
- To force rebuild, bump the version first
- Or manually delete the image from registry if needed

### 7.5 CI check fails (beta releases)

**Problem**: Beta release is blocked because CI check fails.

**Solutions**:
- Wait for CI to complete and pass
- Fix failing tests
- Use `--skip-ci-check` only if absolutely necessary (not recommended)

### 7.6 Branch validation fails

**Problem**: Release script fails with branch validation error.

**Solutions**:
- **Stable releases**: Must be on `main` branch
- **Beta releases**: Must NOT be on `main` branch
- Ensure branch is up-to-date with `origin/main`
- Push all local commits to remote

### 7.7 Low disk space warning

**Problem**: Script warns about low disk space.

**Solutions**:
- Free up disk space (recommended: at least 5GB free)
- Script will continue but builds may fail
- Check with: `df -h`

### 7.8 Verbose debugging

To get detailed debugging information:

```bash
# Enable verbose mode
scripts/release.sh --verbose --bump-version

# Or set DEBUG environment variable
DEBUG=true scripts/release.sh --bump-version
```

This will show:
- Stack traces on errors
- Timestamps on all log messages
- Detailed command output
- Internal state information
